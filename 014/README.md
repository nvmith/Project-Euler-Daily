# Problem 014 - 백만 이하로 시작하는 우박수 중 가장 긴 과정을 거치는 것은? 
 
## 📝 문제 설명  
양의 정수 n에 대하여, 다음과 같은 계산 과정을 반복하기로 합니다.  
  
n → n / 2 (n이 짝수일 때)  
n → 3n + 1 (n이 홀수일 때)  
  
13에 대하여 위의 규칙을 적용해보면 아래처럼 10번의 과정을 통해 1이 됩니다.  
  
13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1  
  
아직 증명은 되지 않았지만, 이런 과정을 거치면 어떤 수로 시작해도 마지막에는 1로 끝나리라 생각됩니다.  
(역주: 이것은 콜라츠 추측 Collatz Conjecture이라고 하며, 이런 수들을 우박수 hailstone sequence라 부르기도 합니다)  
  
그러면, 백만(1,000,000) 이하의 수로 시작했을 때 1까지 도달하는데 가장 긴 과정을 거치는 수는 얼마입니까?  
  
참고: 계산 과정에는 백만을 넘어가는 수가 나와도 괜찮습니다.  

## 🧠 배운 점  
- 수열 길이를 단순 반복문으로 계산하면 너무 느리기 때문에 **메모이제이션(memoization)** 이 핵심
- `unordered_map<ll, int>`을 사용하여 한 번 계산한 수에 대한 결과를 저장해, 이후 동일한 수가 등장했을 때 다시 계산하지 않도록 함
- 각 수 `n`에 대해 다음 수를 재귀적으로 구한 뒤, `memo[n] = 1 + 다음 연산 횟수`로 저장
- 콜라츠 수열 중간에는 100만을 넘어가는 수가 등장하므로 `ll` 타입 사용
- 가장 긴 수열의 **길이**가 아닌 **해당 시작 수**를 추적해야 하므로 `mostNum` 변수 출력
